How to use the framework
========================

The Business Process Optimization framework can be used to simulate an operational business process in combination
with a particular technique for forecasting and a particular technique for planning. The results of different
variants (of the process, forecasting technique or planning technique) can be compared and visualized.

To optimize a business process, three elements must be specified:

* the business process itself, using a problem description.
* a planner that decides which resource to assign to which task at what moment in time, possibly based on predictions.
* optionally, a predicter that either forecasts when cases will arrive to the process, or predicts how long a task in the process will take, or both.

The planner and predicter can be freely defined, but some default planners and predicters also exist.

.. contents:: Contents
    :local:

Quick start
-----------

The code below illustrates how to quickly get started with an example problem.

.. code:: python

    from problems import MMcProblem
    from simulator import Simulator, Reporter
    from planners import GreedyPlanner

    problem_instances = []
    for i in range(20):
        problem_instances.append(MMcProblem().from_generator(51000))
    planner = GreedyPlanner()
    reporter = Reporter(10000)
    results = Simulator.replicate(problem_instances, planner, reporter, 50000)
    print(Reporter.aggregate(results))

The example problem represents an M/M/c queue with an interarrival rate of 10 a service time of 9 and c=2 servers.
The specification of the problem can be inspected in the MMcProblem code.

First, problem instances must be created from the problem. This can automatically be done using the from_generator method, which
exists for each problem. The method takes the amount of simulation time for which instances should be generated as a parameter.
This amount of time should be slightly longer than the simulation time, so the simulator does not run out of cases to simulate.
Each instance consists of cases that arrive at a simulated time. Each case has one or more tasks that must be performed on it (in this case only one task).

Second, a planner should be created that plans the assignment of tasks to resources. A default greedy planner exists that
assigns each task to the first available resource.

Third, a reporter should be created that collects information from the simulator. A default reporter exists that collects
for each instance the number of cases that completed and the average cycle time per case as well as the number of
tasks that completed and the average processing time and waiting time per task. The reporter takes the warmup time as
a parameter, i.e. the simulation time during which no data is collected for reporting.

Now, the simulator can be run for the problem instances with the planner and the reporter. The simulator also takes an
amount of simulation time for which it should be run. The simulator returns a list of results. This is the information
that the reporter generates for each instance, i.e. the list has as many results as there are problem instances.

Finally, the list of results can be aggregated. Each reporter has an aggregate method that aggregated the results
over all problem instances into a single result. The default reporter calculates the averages and 95% confidence
intervals over all the reported statistics: the number of cases, etc.

Defining a problem
------------------

A problem can be defined as an subclass of the abstract class :class:`problems.Problem`.
By doing so it inherits methods for generating problem instances and loading and saving problem instances.

A problem must define:

* The resources that exist.
* The interarrival time distribution of cases.
* The types of tasks that can be performed for cases.
* Rules for what the next task will be when a case first arrives or when a task is completed.
* The processing time distribution for each task.
* The data that is generated by a task.
* For each task the list of resources that is authorized to perform the task.

The resources and task types are static lists, typically of labels for resources and task types. For example,
for the M/M/c problem presented above, we define two resources and a single task type as follows.

.. code:: python

    resources = ["R1", "R2"]
    task_types = ["T"]

The other elements of the problem are implemented as methods that sample from a distribution. For example,
in case of the M/M/c problem, there is a method that samples the processing time from an exponential distribution
with a mean of 10. It must the sampled value. There are also methods that sample the next type of task that
must be performed. However, for an M/M/c queue this is quite simple, because it must always be T as the first
task type and no tasks after T is performed. However, it is also possible to simulate a queuing network, an MDP
or a business process model. In those cases the next task would vary.

More precisely, the remainder of the M/M/c problem can be defined as follows.

.. code:: python

    def processing_time_sample(self, resource, task):
        return random.expovariate(1/9)

    def interarrival_time_sample(self):
        return random.expovariate(1/10)

    def sample_initial_task_type(self):
        return "T"

    def next_task_types_sample(self, task):
        return []

    def resource_pool(self, task_type):
        return self.resources

    def data_sample(self, task_type):
        return dict()

This samples the processing time and the interarrival time from exponential distributions. It samples the initial
task type as T and the subsequent task types as empty, explained above. It specifies that it always returns
the list of all resources as the resources that are authorized to perform a task and it always returns an empty dictionary
as the data that is generated by a task, i.e. there is no data.

Defining a planner
------------------

A planner can be defined as an subclass of the abstract class :class:`planners.Planner`.
A planner is called each time a new task or a resource becomes available in the simulator.
It must then assign resources to tasks and return which resource to assign to which task.
To decide on the assignment, the planner has access to the current state of the cases that
are being simulated via the environment that is passed to it. Most importantly it has access to:

* assigned_tasks: The tasks that are currently assigned.
* unassigned_tasks: The tasks that are currently not assigned.
* available_resources: The set of resources that are currently available.
* busy_resources: The resources that are currently busy.
* reserved_resources: The resources that are currently reserved.
* busy_cases: The cases of which a task is currently being performed.
* now: The current simulation time.

It can use all of this information to decide which resource to assign to which task.

The lifecycle of tasks and resources is important. Initially, all tasks are unassigned and all resources are
available. the list of busy cases identifies the cases and the next tasks to perform for those cases. When the planner
assigns a resource to a task, it also passes the time at which the resource must
start executing the task. The resource then becomes reserved and the task becomes assigned. At the moment the
resource starts executing the task, the resource becomes busy. When the resource is done executing the task,
the task is removed from both the list of assigned and the list of unassigned tasks and the resource becomes
available again. At that moment the task is also removed from the busy cases. The simulator then calculates the
next tasks that must be performed, which are added to the unassigned tasks and the busy cases.

Defining a predicter
--------------------

Running the simulation
----------------------
